# Answers

## Q. 하나의 포트로 수많은 클라이언트의 연결을 받기 위해 사용하는 전략은 무엇무엇이 있을까?

> [How do multiple clients connect simultaneously to one port, say 80, on a server? (stackoverflow)](https://stackoverflow.com/questions/3329641/how-do-multiple-clients-connect-simultaneously-to-one-port-say-80-on-a-server)

### stateless 프로토콜 (ex. UDP)
- 애초에 '연결'이라는 것이 존재하지 않는다.
- 여러 패킷이 연결과 상관없이 도착하는 순서대로 도착한다.

### stateful 프로토콜 (ex. TCP)
- '연결'의 단위는 `소스 ip, 소스 포트,목적지 ip, 목적지 포트` 의 4-tuple이다.
	> - TCP Connection의 식별자 : 4-tuple
	> - IP Connection의 식별자 : 4-tuple + `protocol`
- 4개의 모든 조합이 중복되지 않는 이상, 서로 다른 연결이 만들어진다.
- 따라서 하나의 `호스트:포트` 조합이 서로 다른 수많은 클라이언트들과 연결되더라도 문제될 것이 없다.

## Q. 한 TCP 소켓은 어떻게 동시에 recv / send 할 수 있을까?

> [소켓과 스트림](https://whenday.tistory.com/19)

- 양방향성, 전 이중 모드(full-duplex mode)
- 소켓과 소켓 사이에는 두 개의 스트림이 있고 각각의 입출력을 따로 관리함
- recv / send 할 때 사용하는 소켓 식별자(socket file descriptor)는 recv / send 할 때 read-only 데이터로 활용함
	> - recv : https://github.com/torvalds/linux/blob/master/net/socket.c#L2554
	> - send : https://github.com/torvalds/linux/blob/master/net/socket.c#L2372

### 일식
- 서로 다른 thread를 이용할 수 있다.
- recv나 send는, 단지 packet을 recv, send할 뿐이므로 blocking 작업이 필요 없이 그냥 가능하다.
- 만일 긴 작업이 필요하다면 socket 단에서 하는 게 아니라 작업이 끝나고 socket에는 결과만 밀어넣어주면 되지 않을까.
- 로직상으로 queueing을 구현할 수 있다.<Paste>

## Q. HTTP/2와 HTTP/3은 커넥션을 어떻게 관리할까?

### 일식

#### http2

- 하나의 tcp connection 으로 통신.
- 모든 http2의 커넥션은 persistent, origin당 하나의 connection만 있으면 됨.

#### http3

- UDP를 기반으로 하는 QUIC 프로토콜로 통신.
- handshake, slow start가 필요없음.
- HTTP수준 스트림이 QUIC 스트림에 단순 매핑되어, HoLB가 없음.
- 클라가 첫 요청시 서버의 세션 키를 모르므로, 서버의 connection id를 사용해 initial key를 사용, 통신을 암호화.
- 한번 연결해 놓으면, 서버는 설정을 캐싱했다가 다음 연결때 바로 연결을 성립시키기에 0RTT로 통신을 시작할 수도 있음.
- multiplexing을 여전히 지원함.

## Q. http2의 다중 커넥션은 무엇?

### 일식

- http 1.x는 오로지 하나의 response만 전달될 수 있다는 모델을 따른다.
- http2에서는, http message를 independent frame으로 쪼개서, 끝단에서 조합한다.

---

- stream으로 여러개의 response, request를 묶고, 이를 frame으로 구별.
- frame은 오고가는 데이터의 묶음.
    - HEADERS frame, DATA frame
- server push - html을 동시에 받고, 렌더링해서 필요한 모든 리소스를 같이 받는다.
- vs pipelining?
		- head of blocking. HTTP 1.1의 pipelining은 여전히 큰 response가 뒤의 것들을 막는 현상을 초래한다.
- 결국 하나의 connection만으로 데이터를 주고받을 수 있게 됨.
- 어떻게 여러개의 리소스를 주고받을 수 있는가?
		- 바이너리 포맷의 데이터로 만들어, data frame을 여러개로 나누어 전달할 수 있기 때문.
- http2에서는 헤더 압축도 한다.
		- header table로, 중복 선언된 헤더를 인덱스값만 전송.
				- 새롭게 추가, 변경된 헤더는 HPACK압축으로 전송됨.
- http2는 SSH/TLS 기반에서만 작동.

#### References
> [요청 및 응답 다중화 (HTTP/2 소개)](https://developers.google.com/web/fundamentals/performance/http2/?hl=ko#%EC%9A%94%EC%B2%AD_%EB%B0%8F_%EC%9D%91%EB%8B%B5_%EB%8B%A4%EC%A4%91%ED%99%94)

#### Multiplexed Streams

- 하나의 커넥션으로 동시에 여러 개의 메시지를 주고받을 수 있음
- HTTP 메시지를 독립된 프레임으로 세분화하고, 이 프레임을 인터리빙한 다음, 다른 쪽에서 다시 조립
- 응답 순서에 상관없이 스트림으로 주고받음
- HOL(Head-of-Line, 패킷이 같은 큐에 있는 첫번째 패킷에 의해 지연) 차단 문제 해결
- Stream Prioritization: 리소스 간의 우선 순위를 설정하는 것 (ex. CSS vs img)

## Q. chunked transfer encoding이란 무엇인가?

커넥션이 계속 지속되고 있을 때, 전송의 끝을 알리는 방법은 크게 두 가지가 있다.
- 첫 번째로 `Content-Length` 헤더로 데이터의 사이즈를 주어서, 해당 바이트 크기까지 읽었다면 전송이 끝난 것으로 판단할 수 있다.
- 두 번째로 `chunked transfer encoding` 을 사용할 수 있다. `Transfer-Encoding: chunked` 헤더를 사용한다. 데이터를 청크 단위로 쪼개고, 각각의 청크마다 해당 청크의 길이를 표시해 준다.

예시: 길이가 각각 4, 5, 13(E)인 세 개의 청크

> [Chunked Transfer Encoding (wikipedia)](https://en.wikipedia.org/wiki/Chunked_transfer_encoding)

```
4\r\n
Wiki\r\n
5\r\n
pedia\r\n
E\r\n
 in\r\n
\r\n
chunks.\r\n
0\r\n
\r\n
```

> 서버에서 동적 리소스를 생성해줄 때, 처리가 모두 완료되어야만 리소스를 보내줄 수 있다면, 클라이언트 입장에서는 서버가 처리하는 동안 흰 화면만 보이는 답답함을 느낄 수 있다. 리소스가 완성되지 않았어도 처리된 부분까지만 청크를 보내 주면 이러한 문제를 해결할 수 있다.

