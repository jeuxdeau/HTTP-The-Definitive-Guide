# Answers

## Q. 하나의 포트로 수많은 클라이언트의 연결을 받기 위해 사용하는 전략은 무엇무엇이 있을까?

> [How do multiple clients connect simultaneously to one port, say 80, on a server? (stackoverflow)](https://stackoverflow.com/questions/3329641/how-do-multiple-clients-connect-simultaneously-to-one-port-say-80-on-a-server)

#### stateless 프로토콜 (ex. UDP)
- 애초에 '연결'이라는 것이 존재하지 않는다.
- 여러 패킷이 연결과 상관없이 도착하는 순서대로 도착한다.

#### stateful 프로토콜 (ex. TCP)
- '연결'의 단위는 `소스 ip:소스 포트,목적지 ip:목적지 포트` 의 4-tuple이다.
- 4개의 모든 조합이 중복되지 않는 이상, 서로 다른 연결이 만들어진다.
- 따라서 하나의 `호스트:포트` 조합이 서로 다른 수많은 클라이언트들과 연결되더라도 문제될 것이 없다.

## Q. 한 TCP 소켓은 어떻게 동시에 read / write 할 수 있을까?

> [소켓과 스트림](https://whenday.tistory.com/19)

- 양방향성, 전 이중 모드(full-duplex mode)
- 소켓과 소켓 사이에는 두 개의 스트림이 있고 각각의 입출력을 따로 관리함

## Q. HTTP/2와 HTTP/3은 커넥션을 어떻게 관리할까?

### http/2.0의 다중 커넥션

**References**
> [요청 및 응답 다중화 (HTTP/2 소개)](https://developers.google.com/web/fundamentals/performance/http2/?hl=ko#%EC%9A%94%EC%B2%AD_%EB%B0%8F_%EC%9D%91%EB%8B%B5_%EB%8B%A4%EC%A4%91%ED%99%94)

#### Multiplexed Streams

- 하나의 커넥션으로 동시에 여러 개의 메시지를 주고받을 수 있음
- HTTP 메시지를 독립된 프레임으로 세분화하고, 이 프레임을 인터리빙한 다음, 다른 쪽에서 다시 조립
- 응답 순서에 상관없이 스트림으로 주고받음
- HOL(Head-of-Line, 패킷이 같은 큐에 있는 첫번째 패킷에 의해 지연) 차단 문제 해결
- Stream Prioritization: 리소스 간의 우선 순위를 설정하는 것 (ex. CSS vs img)

## Q. chunked transfer encoding이란 무엇인가?

커넥션이 계속 지속되고 있을 때, 전송의 끝을 알리는 방법은 크게 두 가지가 있다.
- 첫 번째로 `Content-Length` 헤더로 데이터의 사이즈를 주어서, 해당 바이트 크기까지 읽었다면 전송이 끝난 것으로 판단할 수 있다.
- 두 번째로 `chunked transfer encoding` 을 사용할 수 있다. `Transfer-Encoding: chunked` 헤더를 사용한다. 데이터를 청크 단위로 쪼개고, 각각의 청크마다 해당 청크의 길이를 표시해 준다.

예시: 길이가 각각 4, 5, 13(E)인 세 개의 청크

> [Chunked Transfer Encoding (wikipedia)](https://en.wikipedia.org/wiki/Chunked_transfer_encoding)

```
4\r\n
Wiki\r\n
5\r\n
pedia\r\n
E\r\n
 in\r\n
\r\n
chunks.\r\n
0\r\n
\r\n
```

> 서버에서 동적 리소스를 생성해줄 때, 처리가 모두 완료되어야만 리소스를 보내줄 수 있다면, 클라이언트 입장에서는 서버가 처리하는 동안 흰 화면만 보이는 답답함을 느낄 수 있다. 리소스가 완성되지 않았어도 처리된 부분까지만 청크를 보내 주면 이러한 문제를 해결할 수 있다.
